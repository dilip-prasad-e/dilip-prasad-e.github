<!DOCTYPE html>
<html>
<head>
<link rel="stylesheet" href="style\style.css">
<title> Stuff!!! </title>
</head>
<body>
<header class="page1-header">
<p id="study">
Study Materials 
</p> 
</header>
<section class="page1-section">
<pre>

<b id="Software Testing:">Software Testing:</b>	<a href="https://dilip-prasad-e.github.io/dilip-prasad-e.github.io/index.html" class="button" type="submit" >study</a>

Software testing is a process, to evaluate the functionality of a software application with an intent to find whether the 
developed software met the specified requirements or not and to identify the defects to ensure that the product is defect free 
in order to produce the quality product.

Let's see standard definition, software testing types such as manual and automation testing, testing methods, testing approaches 
and types of black box testing.

Definition:
According to ANSI/IEEE 1059 standard - A process of analyzing a software item to detect the differences between existing and 
required conditions (i.e., defects) and to evaluate the features of the software item.

Software Testing Types:
Manual Testing: Manual testing is the process of testing the software manually to find the defects. Tester should have the 
perspective of end users and to ensure all the features are working as mentioned in the requirement document. In this process, 
testers execute the test cases and generate the reports manually without using any automation tools.

Automation Testing: Automation testing is the process of testing the software using an automation tool to find the defects. 
In this process, testers execute the test scripts and generate the test results automatically by using automation tools. 
Some of the famous automation testing tools for functional testing are QTP/UFT and Selenium.

Testing Methods:
Static Testing
Dynamic Testing
Static Testing: It is also known as Verification in Software Testing. Verification is a static method of checking documents 
and files. Verification is the process, to ensure that whether we are building the product right i.e., to verify the requirements 
which we have and to verify whether we are developing the product accordingly or not.

Activities involved here are Inspections, Reviews, Walkthroughs

Dynamic Testing: It is also known as Validation in Software Testing. Validation is a dynamic process of testing the real product. 
Validation is the process, whether we are building the right product i.e., to validate the product which we have developed 
is right or not.

Activities involved in this is Testing the software application

Testing Approaches:
White Box Testing
Black Box Testing
Grey Box Testing
White Box Testing: It is also called as Glass Box, Clear Box, Structural Testing. White Box Testing is based on applications 
internal code structure. In white-box testing, an internal perspective of the system, as well as programming skills, are used 
to design test cases. This testing is usually done at the unit level.

Black Box Testing: It is also called as Behavioral/Specification-Based/Input-Output Testing. Black Box Testing is a software 
testing method in which testers evaluate the functionality of the software under test without looking at the internal code 
structure.

Grey Box Testing: Grey box is the combination of both White Box and Black Box Testing. The tester who works on this type of 
testing needs to have access to design documents. This helps to create better test cases in this process.

Testing Levels:
Unit Testing
Integration Testing
System Testing
Acceptance Testing
Unit Testing: Unit Testing is done to check whether the individual modules of the source code are working properly. i.e. 
testing each and every unit of the application separately by the developer in the developer's environment. It is AKA Module 
Testing or Component Testing

Integration Testing: Integration Testing is the process of testing the connectivity or data transfer between a couple of unit 
tested modules. It is AKA I&T Testing or String Testing. It is subdivided into Top-Down Approach, Bottom-Up Approach and 
Sandwich Approach (Combination of Top Down and Bottom Up).

System Testing (end to end testing): It's a black box testing. Testing the fully integrated application this is also called 
as end to end scenario testing. To ensure that the software works in all intended target systems. Verify thorough testing 
of every input in the application to check for desired outputs. Testing of the users experiences with the application.

Acceptance Testing: To obtain customer sign-off so that software can be delivered and payments received. Types of Acceptance 
Testing are Alpha, Beta & Gamma Testing.

Types of Black Box Testing:
Functionality Testing
Non-functionality Testing
Functional testing: In simple words, what the system actually does is functional testing. To verify that each function of 
the software application behaves as specified in the requirement document. Testing all the functionalities by providing 
appropriate input to verify whether the actual output is matching the expected output or not. It falls within the scope of 
black box testing and the testers need not concern about the source code of the application.

Non-functional testing: In simple words, how well the system performs is non-functionality testing. Non-functional testing 
refers to various aspects of the software such as performance, load, stress, scalability, security, compatibility etc., Main 
focus is to improve the user experience on how fast the system responds to a request.

The Ultimate list of Types of Testing:
Let's see different Types of Software Testing one by one.

1. Functional testing: In simple words, what the system actually does is functional testing. To verify that each function 
of the software application behaves as specified in the requirement document. Testing all the functionalities by providing 
appropriate input to verify whether the actual output is matching the expected output or not. It falls within the scope of 
black box testing and the testers need not concern about the source code of the application.

2. Non-functional testing: In simple words, how well the system performs is non-functionality testing. Non-functional testing 
refers to various aspects of the software such as performance, load, stress, scalability, security, compatibility etc., Main 
focus is to improve the user experience on how fast the system responds to a request.

3. Manual testing: Manual testing is the process of testing the software manually to find the defects. A tester should have 
the perspective of an end user and to ensure all the features are working as mentioned in the requirement document. In this 
process, testers execute the test cases and generate the reports manually without using any automation tools.

4. Automated testing: Automation testing is the process of testing the software using an automation tool to find the defects. 
In this process, executing the test scripts and generating the results are performed automatically by automation tools. Some 
most popular tools to do automation testing are HP QTP/UFT, Selenium WebDriver, etc.,

Manual Testing Vs Automation Testing
Manual Testing:
Manual testing is the process of testing the software manually to find the defects. Tester should have the perspective of an 
end user and to ensure all the features are working as mentioned in the requirement document. In this process, testers execute 
the test cases and generate the reports manually without using any automation tools.

Advantages:
Manual testing can be done on all kinds of applications
It is preferable for short life cycle products
Newly designed test cases should be executed manually
Application must be tested manually before it is automated
It is preferred in the projects where the requirements change frequently and for the products where the GUI changes constantly
It is cheaper in terms of initial investment compared to Automation testing
It requires less time and expense to begin productive manual testing
It allows tester to perform adhoc testing
There is no necessity to the tester to have knowledge on Automation Tools

Disadvantages:
Manual Testing is time-consuming mainly while doing regression testing.
Expensive over automation testing in the long run

Automation Testing:
Automation testing is the process of testing the software using an automation tools to find the defects. In this process, 
executing the test scripts and generating the results are performed automatically by automation tools. Some most popular 
tools to do automation testing are HP QTP/UFT, Selenium WebDriver, etc.,


Advantages:
Automation testing is faster in execution
It is cheaper compared to manual testing in a long run
Automated testing is more reliable
Automated testing is more powerful and versatile
It is mostly used for regression testing
It does not require human intervention. Test scripts can be run unattended
It helps to increase the test coverage

Disadvantages:
It is recommended only for stable products
Automation testing is expensive initially
Most of the automation tools are expensive
It has some limitations such as handling captcha, fonts, color
Huge maintenance in case of repeated changes in the requirements
Not all the tools support all kinds of testing. Such as windows, web, mobility, performance/load testing

5. Black box testing: Black Box Testing is a software testing method in which testers evaluate the functionality of the 
software under test without looking at the internal code structure. This can be applied to every level of software testing 
such as Unit, Integration, System and Acceptance Testing.

6. Glass box testing - Refer white box testing

7. White box testing: White Box Testing is also called as Glass Box, Clear Box, and Structural Testing. It is based on applications 
internal code structure. In white-box testing, an internal perspective of the system, as well as programming skills, are used to 
design test cases. This testing usually was done at the unit level.

8. Specification-based testing: Refer black-box testing.

9. Structure-based testing: Refer white-box testing.

10. Gray box testing: Grey box is the combination of both White Box and Black Box Testing. The tester who works on this 
type of testing needs to have access to design documents. This helps to create better test cases in this process.

11. Unit testing: Unit Testing is also called Module Testing or Component Testing. It is done to check whether the individual 
unit or module of the source code is working properly. It is done by the developers in the developer's environment.

12. Component testing: Refer Unit Testing

13. Module testing: Refer Unit Testing

14. Integration testing: Integration Testing is the process of testing the interface between the two software units. Integration 
testing is done by multiple approaches such Big Bang Approach, Top-Down Approach, Bottom-Up Approach, and Hybrid Integration approach.

15. System testing: Testing the fully integrated application to evaluate the system's compliance with its specified 
requirements is called System Testing AKA End to End testing. Verifying the completed system to ensure that the application 
works as intended or not.

16. Acceptance testing: It is also known as pre-production testing.  This is done by the end users along with the testers 
to validate the functionality of the application. After successful acceptance testing. Formal testing conducted to determine 
whether an application is developed as per the requirement. It allows the customer to accept or reject the application. Types 
of acceptance testing are Alpha, Beta & Gamma.

17. Big bang Integration Testing: Combining all the modules once and verifying the functionality after completion of 
individual module testing.

Top down and bottom up are carried out by using dummy modules known as Stubs and Drivers. These Stubs and Drivers are used 
to stand-in for missing components to simulate data communication between modules.

18. Top-down Integration Testing: Testing takes place from top to bottom. High-level modules are tested first and then 
low-level modules and finally integrating the low-level modules to a high level to ensure the system is working as intended. 
Stubs are used as a temporary module if a module is not ready for integration testing.

19. Bottom-up Integration Testing: It is a reciprocate of the Top-Down Approach. Testing takes place from bottom to up. 
Lowest level modules are tested first and then high-level modules and finally integrating the high-level modules to a low 
level to ensure the system is working as intended. Drivers are used as a temporary module for integration testing.

20. Hybrid Integration Testing: Hybrid integration testing is the combination of both Top-down and bottom-up integration 
testing.

21. Alpha testing: Alpha testing is done by the in-house developers (who developed the software) and testers. Sometimes 
alpha testing is done by the client or outsourcing team with the presence of developers or testers.

22. Beta testing: Beta testing is done by a limited number of end users before delivery. Usually, it is done in the client 
place.
23. Gamma Testing: Gamma testing is done when the software is ready for release with specified requirements. It is done at 
the client place. It is done directly by skipping all the in-house testing activities.

24. Equivalence partitioning testing: Equivalence Partitioning is also known as Equivalence Class Partitioning. In equivalence 
partitioning, inputs to the software or system are divided into groups that are expected to exhibit similar behavior, so they 
are likely to be proposed in the same way. Hence selecting one input from each group to design the test cases.

25. Boundary value analysis testing: Boundary value analysis (BVA) is based on testing the boundary values of valid and invalid 
partitions. The Behavior at the edge of each equivalence partition is more likely to be incorrect than the behavior within 
the partition, so boundaries are an area where testing is likely to yield defects. Every partition has its maximum and minimum 
values and these maximum and minimum values are the boundary values of a partition. A boundary value for a valid partition is 
a valid boundary value. Similarly, a boundary value for an invalid partition is an invalid boundary value.

26. Decision tables testing: Decision Table is aka Cause-Effect Table. This test technique is appropriate for functionalities 
which has logical relationships between inputs (if-else logic). In Decision table technique, we deal with combinations of inputs. 
To identify the test cases with decision table, we consider conditions and actions. We take conditions as inputs and actions as outputs.

27. Cause-effect graph testing- Refer Decision Table Testing

28. State transition testing: Using state transition testing, we pick test cases from an application where we need to test 
different system transitions. We can apply this when an application gives a different output for the same input, depending 
on what has happened in the earlier state.

29. Exhaustive Testing: Testing all the functionalities using all valid and invalid inputs and preconditions is known as 
Exhaustive testing.

30. Early Testing: Defects detected in early phases of SDLC are less expensive to fix. So conducting early testing reduces 
the cost of fixing defects.

31. Use case testing: Use case testing is carried out with the help of use case document. It is done to identify test 
scenarios to test end to end testing

32. Scenario testing: Scenario testing is a software testing technique which is based on a scenario. It involves in 
converting business requirements to test scenarios for better understanding and achieve end to end testing. A well designed 
scenario should be motivating, credible, complex and the outcome of which is easy to evaluate.

33. Documentation testing: Documentation testing is done to validate the documented artifacts such as requirements, test 
plan, traceability matrix, test cases.

34. Statement coverage testing: Statement coverage testing is a white box testing technique which is to validate whether each 
and every statement in the code is executed at least once.

35. Decision coverage testing/branch coverage testing: Decision coverage or branch coverage testing is a white box testing 
technique which is to validate every possible branch is executed at least once.

36. Path testing: Path coverage testing is a white box testing technique which is to validate that all the paths of the 
program are executed at least once.

37. Mutation testing: Mutation testing is a type of white box testing which is to change (mutate) certain statements in the 
source code and verify if the tests  are able to find the errors.

38. Loop testing: Loop testing is a white box testing technique which is to validate the different kind of loops such as 
simple loops, nested loops, concatenated loops and unstructured loops.

39. Performance testing: This type of testing determines or validates the speed, scalability, and/or stability characteristics 
of the system or application under test. Performance is concerned with achieving response times, throughput, and resource-utilization 
levels that meet the performance objectives for the project or product.

40. Load testing: It is to verify that the system/application can handle the expected number of transactions and to verify 
the system/application behavior under both normal and peak load conditions.

41. Stress testing: It is to verify the behavior of the system once the load increases more than its design expectations.

42. Soak testing: Running a system at high load for a prolonged period of time to identify the performance problems is 
called Soak Testing.

43. Endurance testing: Refer Soak testing

44. Stability testing: Refer Soak testing

45. Scalability Testing: Scalability testing is a type of non-functional testing. It is to determine how the application 
under test scales with increasing workload.

46. Volume testing: It is to verify that the system/application can handle a large amount of data

47. Robustness testing: Robustness testing is a type of testing that is performed to validate the robustness of the 
application.

48. Vulnerability testing: Vulnerability testing is the process of identifying the vulnerabilities or weakness in the 
application.

49. Adhoc testing: Ad-hoc testing is quite opposite to the formal testing. It is an informal testing type. In Adhoc testing, 
testers randomly test the application without following any documents and test design techniques. This testing is primarily 
performed if the knowledge of testers in the application under test is very high. Testers randomly test the application without 
any test cases or any business requirement document.

50. Exploratory testing: Usually, this process will be carried out by domain experts. They perform testing just by exploring 
the functionalities of the application without having the knowledge of the requirements.

51. Retesting: To ensure that the defects which were found and posted in the earlier build were fixed or not in the current build. 
Say, Build 1.0 was released. Test team found some defects (Defect Id 1.0.1, 1.0.2) and posted. Build 1.1 was released, now testing 
the defects 1.0.1 and 1.0.2 in this build is retesting.

52. Regression testing: Repeated testing of an already tested program, after modification, to discover any defects introduced or 
uncovered as a result of the changes in the software being tested or in another related or unrelated software components.

53. Smoke testing: Smoke Testing is done to make sure if the build we received from the development team is testable or not. It is 
also called as "Day 0" check. It is done at the "build level". It helps not to waste the testing time to simply testing the whole 
application when the key features don't work or the key bugs have not been fixed yet.

54. Sanity testing: Sanity Testing is done during the release phase to check for the main functionalities of the application 
without going deeper. It is also called as a subset of Regression testing. It is done at the "release level". At times due to 
release time constraints rigorous regression testing can't be done to the build, sanity testing does that part by checking 
main functionalities.

55. Dynamic testing: Dynamic testing involves in the execution of code. It validates the output with the expected outcome

56. Static testing: Static Testing involves in reviewing the documents to identify the defects in the early stages of SDLC.

57. Monkey testing: Perform abnormal action on the application deliberately in order to verify the stability of the application.

58. Gorilla testing: Gorilla testing is done by testers, sometimes developers also join hands with testers. It involves 
testing a system repeatedly to test the robustness of the system.

59. Usability testing: To verify whether the application is user-friendly or not and was comfortably used by an end user or 
not. The main focus in this testing is to check whether the end user can understand and operate the application easily or not. 
An application should be self-exploratory and must not require training to operate it.

60. Accessibility testing: Accessibility testing is a subset of usability testing. It aims to discover how easily people with 
disabilities (such as visual Impairments, Physical Impairment, Hearing Impairment, Cognitive Impairment, Learning Impairment) 
can use a system.

61. Compatibility testing: It is to deploy and check whether the application is working as expected in a different 
combination of environmental components.

62. Configuration testing: Configuration testing is the process of testing an application with each one of the supported 
hardware and software configurations to find out whether the application can work without any issues.

63. Localization testing: Localization is a process of adapting globalization software for a specific region or language 
by adding local specific components.

64. Globalization testing: Globalization is a process of designing a software application so that it can be adapted to various 
languages and regions without any changes.

65. Internationalization testing- Refer Globalization testing

66. Positive Testing: It is to determine what system supposed to do. It helps to check whether the application is justifying 
the requirements or not.

67. Negative testing: It is to determine what system not supposed to do. It helps to find the defects from the software.

68. Security testing: Security testing is a process to determine whether the system protects data and maintains functionality 
as intended.

What is Security Testing?
Security testing is a process to determine whether the system protects data and maintains functionality as intended.

Security testing aims to find out all possible loopholes and weaknesses of the system in the starting stage itself to avoid 
inconsistent system performance, unexpected breakdown, loss of information, loss of revenue, loss of customer's trust.

It comes under Non-functional Testing.

We can do security testing using both manual and automated security testing tools and techniques. Security testing reviews 
the existing system to find vulnerabilities.

Most of the companies perform security testing on newly deployed or developed software, hardware, and network or information 
system environment. But it's highly recommended by experts to make security testing as a part of information system audit 
process of an existing information system environment in detecting all possible security risks and help developers in fixing 
them.

Security testing aims at covering following basic security components

Authentication
Authorization
Availability
Confidentiality
Integrity
Non-repudiation
Why Security Testing is Important?
Security testing is important due to the increase in the number of privacy breaches that websites are facing today. In 
order to avoid these privacy breaches, software development organizations have to adopt security testing in their development 
strategy based on testing methodologies and latest industry standards.

It is important to adopt Security Process in each and every phase of SDLC.

Requirement Phase: Security analysis of all the requirements
Design Phase: Implementation of Test Plan including Security tests.
Code & Unit Testing: Security White Box Testing
Integration Testing: Black Box Testing
System Testing: Black Box Testing & Vulnerability Scanning
Implementation of System Testing: Penetration Testing & Vulnerability Scanning
Support: Impact Analysis

Top Vulnerabilities:
Security tests include testing for vulnerabilities such as

SQL Injection
Cross-Site Scripting (XSS)
Session Management
Broken Authentication
Cross-Site Request Forgery (CSRF)
Security Misconfiguration
Failure to Restrict URL Access
Secure Data Exposure
Insecure Direct Object Reference
Missing Function Level Access Control
Using Components with Known Vulnerabilities
Unvalidated Redirects and Forwards
Types of Security Testing:
There are seven main types of security testing which are presented below.

Vulnerability Scanning:

In vulnerability scanning (aka vulnerability assessment), we just identify and report the vulnerability using 
vulnerability scanning tools.

It's the first step to improve the security of a system.

A vulnerability assessment report should contain the title, the description and the severity of a vulnerability.

Security Scanning:

Security scanning is done to find weak points in the security of network and system and also provides solutions to 
reduce these risks.

Penetration Testing:

In Penetration testing (aka Pen test), we identify the vulnerabilities and attempt to exploit them using penetration 
testing tools. We repeat the same penetration tests until the system is negative to all those tests.

Pen testing can be divided into three techniques such as manual penetration testing, automated penetration testing and a 
combination of both manual & automated penetration testing.

Risk Assessment:

Risk assessment involves reviewing and analyzing security risks that later will be prioritized as Low, Medium and High. 
It also recommends possible ways to prevent the risk.

Security Auditing:

Security auditing is the procedure of defining security flaws. It is an internal inspection of systems to find security flaws. 
In some cases, an audit is done via line by line inspection of code

Ethical Hacking:

Ethical hacking is done on a system with an intent to find and expose security issues in the system. Ethical hacking is done 
by a white hat hacker. White hat hacker is a security professional who uses their skills in a legitimate manner to reveal 
the defects of a system.

Posture Assessment:

Posture assessment is a combination of security scanning, ethical hacking, and risk assessment to present the security posture 
of a system or organization.
Security Testing Tools:
To find the flaws and vulnerabilities in a web application, there are many free, paid, and open source security testing tools 
available in the market. We know that the advantage of open source tools are we can easily customize it to match our requirements. 
We are here to showcase some of the top __ open source security testing tools.

We use security testing tools for checking how secure a website or web application is.

Open Source Security Testing Tools:

Some of the open source security testing tools are Zed Attack Proxy, Wfuzz, Wapiti etc.,

Commercial Security Testing Tools:

Some of the commercial security testing tools are GrammaTech, Appscan, Veracode etc.,

Conclusion:

We know how important is security testing in current days. It aims to find out all possible loopholes and weaknesses of the system. 
Testers play a role of an attacker to find out security related bugs in the system.

69. Penetration testing: Penetration testing is also known as pen testing. It is a type of security testing. It is performed 
to evaluate the security of the system.

What is a Penetration Testing?
Penetration testing is also a type of Security testing which is performed to evaluate the security of the system (hardware, 
software, networks or an information system environment). The goal of this testing is to find all the security vulnerabilities 
that are present in an application by evaluating the security of the system with malicious techniques and to protect the data 
from the hackers and maintain functionality of the system. It is a type of Non-functional testing which intends to make authorized 
attempts to violate the security of the system. It is also known as Pen Testing or Pen Test and the tester who does this testing 
is a penetration tester aka ethical hacker.

Why is Penetration Testing necessary?
If a system is not secured, then an attacker can take authorized access to the system. Penetration testing evaluates the security 
of a system and protects it against internal and external threats. It identifies the vulnerabilities and determines whether 
unauthorized access or other malicious activity is possible.

Organizations conduct penetration testing for a number of reasons

To prevent data breaches
To check security controls
To meet compliance requirements
To ensure the security of new applications
To access incident detection and response effectiveness
How often to conduct pen testing?
Cyber-attacks are quite often in current days. It is very important to conduct regular vulnerability scans and penetration testing 
to detect recently discovered and previously unknown vulnerabilities.

The frequency of conducting pen testing should depend on your organization's security policy. However, conducting pen testing 
regularly can determine the weaknesses of your system and keep it stay away from security breaches.

Usually, pen testing is done after the deployment of new infrastructure and applications. Also, it is done after major changes 
to infrastructure and applications.

Vulnerability scanning examines the servers for vulnerabilities. We have to make sure the vulnerabilities we found are not false 
positives. Actually reporting false positives is a downside of vulnerability scanning.

Penetration testing examines the servers for vulnerabilities and exploits them.

Both vulnerability scanning and penetration testing can test an organizations ability to detect security breaches. Organizations 
need to scan both the external and internal infrastructure and applications to protect against external and internal threats.

Organizations have to conduct regular penetration testing for the following reasons:

To find security vulnerabilities in a system
To secure user data
To test applications that are often the avenues of attack
To identify new bugs in an existing system after deployment or after major changes done in the system
To prevent the black hat attacks and guards the user data
To control revenue loss
To improve the existing security standards
What are the phases of Penetration Testing?
The process of penetration testing can be divided into five phases, which are as follows:

1. Planning phase

In this phase, we define the scope (which system to test and the goals and objectives to achieve with the penetration test) and 
the resources and the tools (vulnerability scanners or penetration testing tools) to employ for test execution

2. Discovery phase

In this phase, we collect as much information as possible about the systems that are in the scope of the penetration test.

3. Vulnerability assessment:

In vulnerability assessment, we just identify and report the vulnerability using vulnerability scanning tools.

4. Exploitation Phase

In this phase, we try to exploit the vulnerabilities identified in the previous phase (i.e., discovery phase) to gain access to 
the target system.

5. Reporting Phase

In this phase, we document all the results and findings in an effective manner. This report will be used as a reference document 
while mitigating activities to address the identified vulnerabilities.

What are the root causes of Security Vulnerabilities?
Some of the root causes of Security Vulnerabilities are as follows

Complexity:

Security vulnerabilities rise in proportion to the complexity of a system. Complexity in terms of software, hardware, information, 
businesses, and processes introduce more security vulnerabilities.

Connectivity:

Every unsecured connection is a potential avenue for exploitation.

Design Flaws:
There shouldn't be any design bugs in software and hardware. These bugs can expose businesses to significant risks.

Configuration:

Poor system configuration introduces security vulnerabilities.

User Input:

Data received through SQL injections, buffer overflows etc., can be designed to attack the receiving system.

Management:

Management should have a proper risk management plan to avoid security vulnerabilities in the system.

Passwords:

Passwords are there to avoid unauthorized access and secure your personal data. Unsecured passwords (sharing with others, writing 
them down somewhere, setting easy to guess) allows hackers to guess your password easily.

Lack of training:

Lack of training leads to human errors. Human errors can be prevented by giving proper training to the employees.

Human errors:

Human errors such as improper disposal of documents, coding errors, giving out passwords to phishing sites are a significant 
source of security vulnerabilities.

Communication:

Communication channels such as telephone, mobile, internet give scope for security vulnerabilities.

Social:

Employees disclosing sensitive information with outsiders is one of the common reasons for security threats.

What is the difference between Penetration Testing & Vulnerability Scanning?

Before looking into the difference between penetration testing and vulnerability scanning. Let's see two most used terms such as 
vulnerability and exploit.

What is a Vulnerability?

A vulnerability is a security weakness or flaw which can be exploited by an attacker, to perform unauthorized actions within a 
system.

What Is An Exploit?

An exploit is a software program that takes advantage of a vulnerability to cause unintended behavior to occur on a system. 
This action is done to gain control of a system to attack it.

Now let's see the difference between Penetration testing and vulnerability assessment.

There is a confusion in the industry on the difference between Penetration Testing & Vulnerability Scanning. Even though these 
two terms are commonly interchanged but there are some differences between these two terms. Penetration testing is not the same 
as the vulnerability testing.

Vulnerability Scanning:

In vulnerability scanning (aka vulnerability assessment), we just identify and report the vulnerability using vulnerability 
scanning tools.

It's the first step to improve the security of a system.

A vulnerability assessment report should contain the title, the description and the severity of a vulnerability.

Penetration Testing:

In Penetration testing (aka Pen test), we identify the vulnerabilities and attempt to exploit them using penetration testing 
tools. We repeat the same penetration tests until the system is negative to all those tests.

A penetration testing report lists the vulnerabilities that were exploited successfully.

If an organization is interested in protecting their system from security issues then they should carry out vulnerability 
assessment and penetration testing on a regular basis.

Pen testing can be divided into three techniques such as manual penetration testing, automated penetration testing and a 
combination of both manual & automated penetration testing.

By using automated penetration testing tools, it is not possible to find all vulnerabilities. Some vulnerabilities can be 
identified using a manual scan. So, experienced pen testers use their experience and skills to attack a system using manual 
penetration testing.

Who Performs Pen-testing?
Pen-testing can be performed by Testers or Network Specialists or Security Consultants.

Role and Responsibilities of Penetration Testers:
Responsibilities of penetration testers vary from company to company. However, there are several core responsibilities common 
to all pen testers such as

Understand complex computer systems and technical cybersecurity terms
Collect the required information from the organization to enable penetration tests
Plan and create penetration methods, scripts, and tests
Carry out onsite testing of clients infrastructure and remote testing of clients network to expose weaknesses in security
Work with clients to determine their requirements from the test
Conducts penetration testing and vulnerability scanning using automated tools, ad-hoc tools, and manual testing
Ability to analyze root causes and deliver strategic recommendations during security reviews
Create reports and recommendations from your findings
Understand how the flaws that you identify could affect business, or business function if they're not fixed.
The flaws that you identify should be reproducible so that it will be easy for developers to fix them
All the data and information should be kept confidential
Types of Penetration Testers?

Black hat penetration testers
White hat penetration testers
Grey hat penetration testers
What is the difference between Black, White and Grey hat hackers?
Black Hat Hackers:

Black hat hackers (aka Black hats) are considered as cybercriminals. They use their skills with an evil motive for personal 
or financial gains. They break into computer networks to destroy data or make the system unusable for those who are authorized 
to use the system. Usually, they involve in hacking banks, stealing credit card information, creating and using a botnet to 
perform DDoS (Distributed Denial of Service) attacks etc.,

White Hat Hackers:

White hat hackers (aka White hats) are usually called ethical hackers. Ethical hackers work for good reasons rather than evil. 
Usually, companies recruit these white hat hackers as full-time employees and also some companies work with these white hat 
hackers on contract basis as security specialists to find security loopholes of their system. White hat hackers attack a system 
after getting permission from the owner of the system.

Grey Hat Hackers:

Grey hat hackers (aka Grey hats) may hack a system for ethical and unethical reasons. Activities of these Grey hat hackers fall 
somewhere between black hat hackers and white hat hackers. Grey hat hackers find vulnerabilities in a system. This type of hacking 
is considered illegal because they attack the system without getting permission from the owner of the system. They find for the 
security vulnerabilities but not for bad purposes. After finding security vulnerabilities, they report them to the owner of the 
system. Sometimes they request a fee to fix the issue. If the owner doesn't respond then sometimes the hackers will disclose the 
security flaw to the public.

What are the types of Penetration Tests?
Different types of Pen Testing which are as follows

1. Network Services Tests

Network services pen test aims to identify security weaknesses and vulnerabilities in the network. These tests can be run both 
locally and remotely.

Pen testers should target the following network areas

Firewall config test
Stateful analysis test
Firewall bypass test
IPS deception
DNS level attacks such as Zone transfer testing, Switching or routing issues, and another required network testing
Pen testers also cover some of the most common software packages such as

Secure Shell (SSH)
SQL Server or MySQL
Simple Mail Transfer Protocol (SMTP)
File Transfer Protocol (FTP)
2. Web Application Tests

Web application pen tests (web application penetration testing) aim to identify the security vulnerabilities of web applications, 
web browsers, and their components like ActiveX, Applets, Silverlight and APIs.

3. Client Side Tests

Client-side pen tests aim to find security vulnerabilities and exploit them in client-side software applications.

4. Wireless Tests

Wireless pen tests involved in analyzing the Wi-Fi networks and wireless devices deployed on the client site. Wireless devices 
such as laptops, netbooks, tablets, smartphones, iPods etc.,

5. Social Engineering Tests

Employees disclosing sensitive information with outsiders is one of the common reasons of security threats. All the employees 
should follow security standards and policies to avoid social engineering penetration attempt. These tests are mostly done through 
communication channels such as telephone, mobile, internet and it targets employees, helpdesks and processes.

Social engineering pen tests can be subcategorized into two types

Remote Tests:

Remote tests intend to trick an employee to disclose sensitive information via an electronic means (ie., via Phishing Email Campaign)

Physical Tests:

Strong physical security methods should be applied to protect sensitive information. It involves human handling tactics like 
convincing an employee via phone calls. It is generally using in a military facility.

What are the Types of Pen Testing?
There are three types of Pen Testing which can be used, which are as follows

1. Black Box Penetration Testing
2. White Box Penetration Testing
3. Grey Box Penetration Testing

Black Box Penetration Testing

In Black Box Penetration Testing approach, black box pen testers (Black Hat Hackers) assess the target system without having 
any knowledge of system details. They just have high-level details about the system such as URL or company name. They don't 
examine any programming code. These testers are not ethical hackers. It's impossible to gather information about the target system 
from the owner of the system. So they launch an all-out, brute force attack against the system to find out weaknesses or 
vulnerabilities in a system. This approach is also referred as "trial and error" approach.

White Box Penetration Testing

In White Box Penetration Testing approach, white box pen testers (White Hat Hackers) access the target system with complete 
details about the system. Since they have complete details about the system, white box test can be accomplished much quicker 
compared to black box test. White box pen testers are called ethical hackers. This approach is also known as clear box, glass 
box, open box and structural testing.

Grey Box Penetration Testing

In Grey Box Penetration Testing approach, grey box pen testers (Grey Hat Hackers) utilize both manual and automated testing 
processes. It is a combination of both Black Box and White Box penetration testing techniques. These hackers may attack a system 
for ethical and unethical reasons. These hackers find vulnerabilities in a system. This type of hacking is considered illegal 
because they attack the system without getting permission from the owner of the system.

Limitations of Penetration Testing
Penetration testing cannot find all vulnerabilities in a target system. There are some limitations based on the resources and 
restrictions of a test, such as

Limitations of skills of a pen tester - It's hard to find professional pen testes.
Limitations of scope - most of the organizations leave some tests due to a resource, security constraints etc.,
Limitations of time
Limitations of budget
Limitations of tools used
Penetration Testing Tools:
Pen Testing Tools are classified into Vulnerability Scanners and Vulnerability Attackers. Vulnerability Scanners show you 
the weak spots of the system whereas Vulnerability Attackers show you the weak spots of the system and attack them.

Free Penetration Testing Tools:

Some of the free penetration testing tools (network vulnerability assessment tools/web vulnerability assessment tools) are 
NMap, Nessus, Metasploit, Wireshark, OpenSSL, Cain & Abel, W3af etc.,

Commercial Penetration Testing Tools:

Some of the commercial penetration testing tools are Pure Hacking, Torrid Networks, SecPoint, Veracode etc.,

How to choose a Penetration Testing Tools?
We need to choose a penetration testing based on the following points.

It should be easy to use
It should be easy to configure & deploy
It should scan vulnerabilities easily
Categorization of vulnerabilities based on the severity
It should generate detailed reports and logs
It should be cost-effective in terms of budget
A good support team & technical documentation is essential
Conclusion:

We've prepared this tutorial by keeping software testers in mind and covered everything needed for them to learn and implement 
Penetration Testing at work. Even though it's a beginner's guide for Penetration Testing, we hope you would be able to improve 
your knowledge on Penetration Testing with this tutorial.

If you have any queries, please comment below. If you are a penetration tester, please share your experience in the comment 
section below.

70. Database testing: Database testing is done to validate the data in the UI is matched with the data stored in the database. 
It involves in checking the schema, tables, triggers etc., of the database.

71. Bucket Testing: Bucket testing is a method to compare two versions of an application against each other to determine which 
one performs better.

72. A/B testing: Refer Bucket Testing...

73. Split testing- Refer bucket testing...

74. Reliability Testing: Perform testing on the application continuously for a long period of time in order to verify the 
stability of the application

75. Interface Testing: Interface testing is performed to evaluate whether two intended modules pass data and communicate correctly 
to one another.

76. Concurrency testing: Concurrency testing means accessing the application at the same time by multiple users to ensure the 
stability of the system. This is mainly used to identify deadlock issues.

77. Fuzz testing: Fuzz testing is used to identify coding errors and security loopholes in an application. By inputting a massive 
amount of random data to the system in an attempt to make it crash to identify if anything breaks in the application.

78. GUI Testing: Graphical User Interface Testing is to test the interface between the application and the end user. Mainly testers 
concern about the appearance of the elements such as fonts and colors conforms to design specifications.

79. API testing: API stands for Application Programming Interface. API testing is a type of software testing that involves testing 
APIs using some tools like SOAPUI, PostMan.

80. Agile testing: Agile testing is a type of testing that involves following principles of agile software development methodology. 
In this agile testing, testing is conducted throughout the lifecycle of the continuously evolving project instead of being 
confined to a particular phase.

81. End to end testing- Refer system testing...

82. Recovery testing: Recovery testing is performed in order to determine how quickly the system can recover after the system 
crash or hardware failure. It comes under the type of non-functional testing.

83. Risk-based testing: Identify the modules or functionalities which are most likely cause failures and then testing 
those functionalities.

84. Installation testing: It is to check whether the application is successfully installed and it is working as expected 
after installation.

85. Formal Testing: It is a process where the testers test the application by having pre-planned procedures and proper 
documentation.

86. Pilot testing: Pilot testing is testing carried out under a real-time operating condition by the company in order 
to gain the confidence of the client

87. Backend testing: Refer Database testing...

88. Cross-browser testing: Cross Browser Testing is a type of non-functional test which helps us to ensure that our 
website or web application works as expected in various web browsers.

89. Browser compatibility testing: Refer browser compatibility testing...

90. Forward compatibility testing: Forward compatibility testing is to validate the application under test is working 
as intended in the later versions of software's current version.

91. Backward compatibility testing: Backward compatibility testing is to validate the application under test is working 
as intended in the earlier versions of software's current version.

92. Downward compatibility testing: Refer Backward compatibility testing...

93. Compliance testing: Compliance testing is non-functional testing which is done to validate whether the software meets 
a defined set of standards.

94. Conformance testing: Refer compliance testing...

95. UI testing: In UI testing, testers aim to test both GUI and Command Line Interfaces (CLIs)

Also, refer GUI Testing...

96. Destructive testing: Destructive testing is a testing technique which aims to validate the robustness of the application 
by testing continues until the application breaks.

97. Dependency testing: Dependency testing is a testing technique which examines the requirements of an application for 
pre-conditions, initial states, and configuration for the proper functioning of the application.

98. Crowdsourced testing: Crowdsourced testing is carried out by a community of expert quality assurance testers 
through an online platform.

99. ETL testing: ETL (Extract, Transform and Load) testing involves in validating the data movement from source to destination 
and verifying the data count in both source and destination and verifying data extraction, transformation and also verifying 
the table relations.

100. Data warehouse testing: Refer ETL testing...

101. Fault injection testing: Fault injection testing is a testing technique in which fault is intentionally introduced in 
the code in order to improve the test coverage.

102. Failover testing: Failover testing is a testing technique that validates a system's ability to be able to allocate 
extra resource during the server failure and transferring of the processing part to back-up systems

103. All pair testing: All pair testing approach is to test the application with all possible combination of the values 
of input parameters.

104. Pairwise Testing: Refer All pair testing

Here I am going to conclude different types of software testing types. 



</pre>
</section>
<footer class="page1-footer">
<p id="end"> copyright @ Dilip </p>			<a href="#study" style="color: white;">study</a>
</footer>


</body>
</html>